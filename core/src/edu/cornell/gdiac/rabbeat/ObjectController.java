package edu.cornell.gdiac.rabbeat;

import com.badlogic.gdx.Gdx;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.BitmapFont;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.physics.box2d.BodyDef;
import com.badlogic.gdx.utils.JsonValue;

import edu.cornell.gdiac.assets.AssetDirectory;
import edu.cornell.gdiac.rabbeat.obstacles.*;

import com.badlogic.gdx.graphics.g2d.Animation;
import com.badlogic.gdx.graphics.g2d.TextureAtlas;
import edu.cornell.gdiac.rabbeat.obstacles.enemies.BatEnemy;
import edu.cornell.gdiac.rabbeat.obstacles.enemies.BearEnemy;
import edu.cornell.gdiac.rabbeat.obstacles.enemies.BeeHive;
import edu.cornell.gdiac.rabbeat.obstacles.enemies.HedgehogEnemy;
import edu.cornell.gdiac.rabbeat.obstacles.platforms.MovingPlatform;
import edu.cornell.gdiac.rabbeat.obstacles.platforms.WeightedPlatform;
import edu.cornell.gdiac.rabbeat.ui.GenreUI;
import edu.cornell.gdiac.util.PooledList;
import java.util.ArrayList;
import java.util.HashMap;

public class ObjectController {
    /**
     * The purpose of this class is to instantiate all {@link GameObject}s in our
     * world and keep them in memory.
     * When the world is loaded in from the json, all the objects are created here
     * and placed into
     * an object list. {@link GameController} will use this controller class to
     * update the game logic of
     * each GameObject in the game.
     */
    /** All the objects in the world. */
    public PooledList<GameObject> objects = new PooledList<>();
    /** All objects that are genre-dependent */
    public PooledList<IGenreObject> genreObjects = new PooledList<>();
    /** Queue for adding objects */
    public PooledList<GameObject> addQueue = new PooledList<>();

    /** Reference to the character avatar */
    public Player player;

    /**
     * Physics constants for initialization
     * TODO: constants has some relevant information for game controller and this
     * class does not care
     */
    public JsonValue defaultConstants;
    /** The Json data for the level, generated by Tiled */
    public JsonValue levelJson;

    /** The font for giving messages to the player */
    protected BitmapFont displayFont;

    /** The texture for walls */
    protected TextureRegion blackTile;
    /** The texture for regular platforms */
    protected TextureRegion platformTile;
    /** The texture for regular platform art */
    protected TextureRegion platformTileArt;
    protected TextureRegion longLeft;
    protected TextureRegion longMid;
    protected TextureRegion longRight;

    protected TextureRegion laserTile;
    protected TextureRegion laserTileVertical;

    /** The texture for weighted platforms in Synth mode */
    protected TextureRegion weightedSynth;
    /** The texture for weighted platforms in Jazz mode */
    protected TextureRegion weightedJazz;

    /** The texture for moving platforms in Synth mode */
    protected TextureRegion movingSynth;
    /** The texture for moving platforms in Jazz mode */
    protected TextureRegion movingJazz;

    /** The texture for bullets */
    public TextureRegion bulletTexture;

    /** The texture for bees */
    public TextureRegion beeTexture;

    /** The texture for bees */
    private TextureRegion bearTexture;

    /** The texture for beehives */
    private TextureRegion beehiveTexture;

    /** The texture for hedgehogs */
    private TextureRegion hedgehogTexture;
    /** The texture for the exit condition */
    protected TextureRegion goalTile;
    /** The inactive atlas for a checkpoint */
    protected TextureAtlas checkpointInactiveAtlas;
    /** The inactive animation for a checkpoint */
    protected Animation<TextureRegion> checkpointInactiveAnimation;
    /** The active atlas for a checkpoint */
    protected TextureAtlas checkpointActiveAtlas;
    /** The active animation for a checkpoint */
    protected Animation<TextureRegion> checkpointActiveAnimation;
    /** The rise atlas for a checkpoint */
    protected TextureAtlas checkpointRiseAtlas;
    /** The rise animation for a checkpoint */
    protected Animation<TextureRegion> checkpointRiseAnimation;
    /** The texture for the background*/
    public TextureRegion backgroundTexture;
    /** The texture for the background overlay */
    public TextureRegion backgroundOverlayTexture;
    /** The texture for tinting the pause screen overlay background */
    public TextureRegion pauseWhiteOverlayTexture;

    private TextureRegion enemyDefaultTexture;

    /** The texture for the genre indicator in Synth mode */
    private TextureRegion synthIndicatorTexture;
    /** The texture for the genre indicator in Jazz mode */
    private TextureRegion jazzIndicatorTexture;
    /** The synth genre atlas for the genre indicator */
    public TextureAtlas synthCDAtlas;
    /** The synth animation for the genre indicator */
    private Animation<TextureRegion> synthCDAnimation;
    /** The jazz genre atlas for the genre indicator */
    public TextureAtlas jazzCDAtlas;
    /** The jazz animation for the genre indicator */
    private Animation<TextureRegion> jazzCDAnimation;
    /** The genre indicator UI */
    public GenreUI genreIndicator;

    private HashMap<String, TextureRegion> assets = new HashMap<>();

    /** Reference to the goalDoor (for collision detection) */
    public BoxGameObject goalDoor;

    /** Reference to all the checkpoints */
    public ArrayList<Checkpoint> checkpoints = new ArrayList<>();
    public float[] firstCheckpoint = new float[2];

    /** The player scale for synth */
    private float playerScale = 1f;

    private TextureRegion synthDefaultTexture;
    private TextureRegion synthJazzTexture;

    // PLAYER ANIMATIONS

    // SYNTH
    /** The synth genre idle atlas for the player */
    public TextureAtlas synthIdleAtlas;
    /** The synth genre idle animation for the player */
    public Animation<TextureRegion> synthIdleAnimation;
    /** The synth genre walking atlas for the player */
    public TextureAtlas synthWalkAtlas;
    /** The synth genre walking animation for the player */
    public Animation<TextureRegion> synthWalkAnimation;
    /** The synth genre jumping atlas for the player */
    public TextureAtlas synthJumpAtlas;
    /** The synth genre jumping animation for the player */
    public Animation<TextureRegion> synthJumpAnimation;
    /** The synth genre fall atlas for the player */
    public TextureAtlas synthFallAtlas;
    /** The synth genre fall animation for the player */
    public Animation<TextureRegion> synthFallAnimation;

    // JAZZ
    /** The jazz genre idle atlas for the player */
    public TextureAtlas jazzIdleAtlas;
    /** The jazz genre idle animation for the player */
    public Animation<TextureRegion> jazzIdleAnimation;
    /** The jazz genre walking atlas for the player */
    public TextureAtlas jazzWalkAtlas;
    /** The jazz genre walking animation for the player */
    public Animation<TextureRegion> jazzWalkAnimation;
    /** The jazz genre jumping atlas for the player */
    public TextureAtlas jazzJumpAtlas;
    /** The jazz genre jumping animation for the player */
    public Animation<TextureRegion> jazzJumpAnimation;
    /** The jazz genre fall atlas for the player */
    public TextureAtlas jazzFallAtlas;
    /** The jazz genre fall animation for the player */
    public Animation<TextureRegion> jazzFallAnimation;

    // ENEMY ANIMATIONS
    /** The idle atlas for the bear enemy */
    public TextureAtlas bearIdleAtlas;
    /** The idle animation for the bear enemy */
    public Animation<TextureRegion> bearIdleAnimation;
    /** The attack atlas for the bear enemy */
    public TextureAtlas bearAttackAtlas;
    /** The attack animation for the bear enemy */
    public Animation<TextureRegion> bearAttackAnimation;
    /** The idle atlas for the bat enemy */
    public TextureAtlas batIdleAtlas;
    /** The idle animation for the bat enemy */
    public Animation<TextureRegion> batIdleAnimation;
    /** The synth attack atlas for the bat enemy */
    public TextureAtlas batAttackSynthAtlas;
    /** The synth attack animation for the bat enemy */
    public Animation<TextureRegion> batAttackSynthAnimation;
    /** The jazz attack atlas for the bat enemy */
    public TextureAtlas batAttackJazzAtlas;
    /** The jazz attack animation for the bat enemy */
    public Animation<TextureRegion> batAttackJazzAnimation;
    /** The idle atlas for the bee enemy */
    public TextureAtlas beeAttackAtlas;
    /** The idle animation for the bee enemy */
    public Animation<TextureRegion> beeAttackAnimation;
    /** The idle atlas for the beehive */
    public TextureAtlas beehiveAtlas;
    /** The idle animation for the beehive */
    public Animation<TextureRegion> beehiveAnimation;

    /** The idle atlas for the hedgehog enemy */
    public TextureAtlas hedgehogIdleAtlas;
    /** The idle animation for the hedgehog enemy */
    public Animation<TextureRegion> hedgehogIdleAnimation;
    /** The attack atlas for the hedgehog enemy */
    public TextureAtlas hedgehogAttackAtlas;
    /** The attack animation for the hedgehog enemy */
    public Animation<TextureRegion> hedgehogAttackAnimation;

    private float synthSpeed;
    private float jazzSpeed;
    /** The enemy scale for the enemy */
    private float enemyScale = 1f;

    public int tileSize;

    public ArrayList<GameObject> foreground = new ArrayList<>();
    /** the default beat list is on the downbeats within 2 measures (beat 1 and beat 5)*/
    public int[] defaultBeatList = { 1, 5 };

    //public GameController gc = GameController.getInstance();
    /**
     * Gather the assets for this controller.
     *
     * This method extracts the asset variables from the given asset directory. It
     * should only be called after the asset directory is completed.
     *
     * @param directory Reference to global asset manager.
     */
    public void gatherAssets(AssetDirectory directory) {
//        levelJson = directory.getEntry(GameController.getInstance().getCurrentLevel(), JsonValue.class);
        levelJson = directory.getEntry(GameController.getInstance().getCurrentLevel(), JsonValue.class);
        tileSize = levelJson.getInt("tileheight");

        System.out.println(GameController.getInstance().getCurrentLevel());

        backgroundTexture = new TextureRegion(directory.getEntry("backgrounds:test-bg",Texture.class));
        backgroundOverlayTexture = new TextureRegion(directory.getEntry("backgrounds:overlay",Texture.class));
        pauseWhiteOverlayTexture = new TextureRegion(directory.getEntry("backgrounds:pauseTint", Texture.class));
        enemyDefaultTexture = new TextureRegion(directory.getEntry("player:synth",Texture.class)); //CHANGE FOR ENEMY!
        beeTexture = new TextureRegion(directory.getEntry("enemies:bee", Texture.class));
        bearTexture = new TextureRegion(directory.getEntry("enemies:bear", Texture.class));
        beehiveTexture = new TextureRegion(directory.getEntry("enemies:beehive", Texture.class));
        hedgehogTexture = new TextureRegion(directory.getEntry("enemies:hedgehog", Texture.class));

        // Allocate genre indicator UI
        synthIndicatorTexture = new TextureRegion(directory.getEntry("ui:synthIndicator", Texture.class));
        jazzIndicatorTexture = new TextureRegion(directory.getEntry("ui:jazzIndicator", Texture.class));
        synthCDAtlas = new TextureAtlas(Gdx.files.internal("ui/synthCD.atlas"));
        synthCDAnimation = new Animation<TextureRegion>(1f, synthCDAtlas.findRegions("synthCD"), Animation.PlayMode.LOOP);
        jazzCDAtlas = new TextureAtlas(Gdx.files.internal("ui/jazzCD.atlas"));
        jazzCDAnimation = new Animation<TextureRegion>(1f, jazzCDAtlas.findRegions("jazzCD"), Animation.PlayMode.LOOP);

        defaultConstants = directory.getEntry("defaultConstants", JsonValue.class);
        synthSpeed = defaultConstants.get("player").get("max_speed").getFloat("synth");
        jazzSpeed = defaultConstants.get("player").get("max_speed").getFloat("jazz");
        synthDefaultTexture = new TextureRegion(directory.getEntry("player:synth", Texture.class));
        synthJazzTexture = new TextureRegion(directory.getEntry("player:synth-jazz", Texture.class));

        // Allocating player animations
        // Synth
        // Note: For animations, frame durations must be 1 for AnimationSync to work
        synthIdleAtlas = new TextureAtlas(Gdx.files.internal("player/synthIdle.atlas"));
        synthIdleAnimation = new Animation<TextureRegion>(1f, synthIdleAtlas.findRegions("synthIdle"), Animation.PlayMode.LOOP);

        synthWalkAtlas = new TextureAtlas(Gdx.files.internal("player/synthWalk.atlas"));
        synthWalkAnimation = new Animation<TextureRegion>(0.7f, synthWalkAtlas.findRegions("synthWalk"), Animation.PlayMode.LOOP);

        synthJumpAtlas = new TextureAtlas(Gdx.files.internal("player/synthJump.atlas"));
        synthJumpAnimation = new Animation<TextureRegion>(5/6f, synthJumpAtlas.findRegions("synthJump"), Animation.PlayMode.NORMAL);

        synthFallAtlas = new TextureAtlas(Gdx.files.internal("player/synthFall.atlas"));
        synthFallAnimation = new Animation<TextureRegion>(1.5f, synthFallAtlas.findRegions("synthFall"), Animation.PlayMode.LOOP);

        // Jazz
        jazzIdleAtlas = new TextureAtlas(Gdx.files.internal("player/jazzIdle.atlas"));
        jazzIdleAnimation = new Animation<TextureRegion>(1f, jazzIdleAtlas.findRegions("jazzIdle"), Animation.PlayMode.LOOP);

        jazzWalkAtlas = new TextureAtlas(Gdx.files.internal("player/jazzWalk.atlas"));
        jazzWalkAnimation = new Animation<TextureRegion>(0.9f, jazzWalkAtlas.findRegions("jazzWalk"), Animation.PlayMode.LOOP);

        jazzJumpAtlas = new TextureAtlas(Gdx.files.internal("player/jazzJump.atlas"));
        jazzJumpAnimation = new Animation<TextureRegion>(5/6f, jazzJumpAtlas.findRegions("jazzJump"), Animation.PlayMode.NORMAL);

        jazzFallAtlas = new TextureAtlas(Gdx.files.internal("player/jazzFall.atlas"));
        jazzFallAnimation = new Animation<TextureRegion>(1.5f, jazzFallAtlas.findRegions("jazzFall"), Animation.PlayMode.LOOP);

        // Allocating enemy animations
        // Bear
        bearIdleAtlas = new TextureAtlas(Gdx.files.internal("enemies/bearIdle.atlas"));
        bearIdleAnimation = new Animation<TextureRegion>(1f, bearIdleAtlas.findRegions("bearIdle"), Animation.PlayMode.LOOP);
        bearAttackAtlas = new TextureAtlas(Gdx.files.internal("enemies/bearAttack.atlas"));
        bearAttackAnimation = new Animation<TextureRegion>(1f, bearAttackAtlas.findRegions("bearAttack"), Animation.PlayMode.LOOP);
        //  Bat
        batIdleAtlas = new TextureAtlas(Gdx.files.internal("enemies/bearIdle.atlas"));
        batIdleAnimation = new Animation<TextureRegion>(1f, bearIdleAtlas.findRegions("bearIdle"), Animation.PlayMode.LOOP);
        batAttackJazzAtlas = new TextureAtlas(Gdx.files.internal("enemies/batAttackJazz.atlas"));
        batAttackJazzAnimation = new Animation<TextureRegion>(1f, batAttackJazzAtlas.findRegions("batAttackJazz"), Animation.PlayMode.LOOP);
        batAttackSynthAtlas = new TextureAtlas(Gdx.files.internal("enemies/batAttackSynth.atlas"));
        batAttackSynthAnimation = new Animation<TextureRegion>(1f, batAttackSynthAtlas.findRegions("batAttackSynth"), Animation.PlayMode.LOOP);

        // Bee
        beeAttackAtlas = new TextureAtlas(Gdx.files.internal("enemies/beeAttack.atlas"));
        beeAttackAnimation = new Animation<TextureRegion>(0.25f, beeAttackAtlas.findRegions("beeAttack"),
                Animation.PlayMode.LOOP);

        beehiveAtlas = new TextureAtlas(Gdx.files.internal("enemies/beehive.atlas"));
        beehiveAnimation = new Animation<TextureRegion>(1, beehiveAtlas.findRegions("beehive"),
                Animation.PlayMode.LOOP);
        // Hedgehog
        hedgehogIdleAtlas = new TextureAtlas(Gdx.files.internal("enemies/bearIdle.atlas"));
        hedgehogIdleAnimation = new Animation<TextureRegion>(5/3f, bearIdleAtlas.findRegions("bearIdle"), Animation.PlayMode.LOOP);
        hedgehogAttackAtlas = new TextureAtlas(Gdx.files.internal("enemies/hedgehogAttack.atlas"));
        hedgehogAttackAnimation = new Animation<TextureRegion>(1.5f, hedgehogAttackAtlas.findRegions("hedgehogAttack"), Animation.PlayMode.LOOP);


        // Allocate the tiles
        blackTile = new TextureRegion(directory.getEntry( "world:platforms:blackTile", Texture.class ));
        platformTile = new TextureRegion(directory.getEntry( "world:platforms:platform", Texture.class ));
        platformTileArt = new TextureRegion(directory.getEntry( "world:platforms:platformArt", Texture.class ));
        longLeft = new TextureRegion(directory.getEntry("world:platforms:longPlatform:left", Texture.class ));
        longMid = new TextureRegion(directory.getEntry( "world:platforms:longPlatform:mid", Texture.class ));
        longRight = new TextureRegion(directory.getEntry( "world:platforms:longPlatform:right", Texture.class ));
        laserTile = new TextureRegion(directory.getEntry("world:laser", Texture.class));
        laserTileVertical = new TextureRegion(directory.getEntry("world:verticalLaser", Texture.class));

        weightedSynth = new TextureRegion((directory.getEntry("world:platforms:weightedSynth", Texture.class)));
        weightedJazz = new TextureRegion((directory.getEntry("world:platforms:weightedJazz", Texture.class)));

        movingSynth = new TextureRegion((directory.getEntry("world:platforms:movingSynth", Texture.class)));
        movingJazz = new TextureRegion((directory.getEntry("world:platforms:movingJazz", Texture.class)));

        assets.put("bearpod1", new TextureRegion(directory.getEntry("world:pods:bearpod1", Texture.class)));
        assets.put("bearpod2", new TextureRegion(directory.getEntry("world:pods:bearpod2", Texture.class)));
        assets.put("bgpod1", new TextureRegion(directory.getEntry("world:pods:bgpod1", Texture.class)));
        assets.put("bgpod2", new TextureRegion(directory.getEntry("world:pods:bgpod2", Texture.class)));
        assets.put("dolpod1", new TextureRegion(directory.getEntry("world:pods:dolpod1", Texture.class)));
        assets.put("dolpod2", new TextureRegion(directory.getEntry("world:pods:dolpod2", Texture.class)));
        assets.put("octpod1", new TextureRegion(directory.getEntry("world:pods:octpod1", Texture.class)));
        assets.put("emptypod4", new TextureRegion(directory.getEntry("world:pods:emptypod4", Texture.class)));
        assets.put("wolfpod1", new TextureRegion(directory.getEntry("world:pods:wolfpod1", Texture.class)));
        assets.put("shelf1", new TextureRegion(directory.getEntry("world:shelves:shelf1", Texture.class)));
        assets.put("shelf2", new TextureRegion(directory.getEntry("world:shelves:shelf2", Texture.class)));
        assets.put("shelf3", new TextureRegion(directory.getEntry("world:shelves:shelf3", Texture.class)));
        assets.put("shelf4", new TextureRegion(directory.getEntry("world:shelves:shelf4", Texture.class)));
        assets.put("shelf5", new TextureRegion(directory.getEntry("world:shelves:shelf5", Texture.class)));
        assets.put("light", new TextureRegion(directory.getEntry("world:other:light", Texture.class)));
        assets.put("pipeposter", new TextureRegion(directory.getEntry("world:pipes:pipeposter", Texture.class)));
        assets.put("piperight", new TextureRegion(directory.getEntry("world:pipes:piperight", Texture.class)));
        assets.put("piperightskinny",
                new TextureRegion(directory.getEntry("world:pipes:piperightskinny", Texture.class)));
        assets.put("pipestraight", new TextureRegion(directory.getEntry("world:pipes:pipestraight", Texture.class)));
        assets.put("pipestraightskinny",
                new TextureRegion(directory.getEntry("world:pipes:pipestraightskinny", Texture.class)));
        assets.put("pipeleftskinny",
                new TextureRegion(directory.getEntry("world:pipes:pipeleftskinny", Texture.class)));
        assets.put("bgpipe", new TextureRegion(directory.getEntry("world:pipes:bgpipe", Texture.class)));
        assets.put("bigpipe", new TextureRegion(directory.getEntry("world:pipes:bigpipe", Texture.class)));
        assets.put("bigpipetv", new TextureRegion(directory.getEntry("world:pipes:bigpipetv", Texture.class)));
        assets.put("bigwire", new TextureRegion(directory.getEntry("world:wires:bigwire", Texture.class)));
        assets.put("wires1", new TextureRegion(directory.getEntry("world:wires:wires1", Texture.class)));
        assets.put("wires2", new TextureRegion(directory.getEntry("world:wires:wires2", Texture.class)));

        bulletTexture = new TextureRegion(directory.getEntry("world:bullet", Texture.class));
        goalTile  = new TextureRegion(directory.getEntry( "world:goal", Texture.class ));
        displayFont = directory.getEntry( "fonts:retro" ,BitmapFont.class);

        // Checkpoint
        checkpointInactiveAtlas = new TextureAtlas(Gdx.files.internal("world/checkpoints/checkpointInactive.atlas"));
        checkpointInactiveAnimation = new Animation<TextureRegion>(1f, checkpointInactiveAtlas.findRegions("checkpointInactive"), Animation.PlayMode.LOOP);
        checkpointActiveAtlas = new TextureAtlas(Gdx.files.internal("world/checkpoints/checkpointActive.atlas"));
        checkpointActiveAnimation = new Animation<TextureRegion>(1f, checkpointActiveAtlas.findRegions("checkpointActive"), Animation.PlayMode.LOOP);
        checkpointRiseAtlas = new TextureAtlas(Gdx.files.internal("world/checkpoints/checkpointRise.atlas"));
        checkpointRiseAnimation = new Animation<TextureRegion>(1f, checkpointRiseAtlas.findRegions("checkpointRise"), Animation.PlayMode.LOOP);
    }

    /**
     * Populates all objects into the game.
     *
     * @param scale The draw scale
     */
    public void populateObjects(Vector2 scale) {
        // Populate in-game UI elements
        createGUI();

        // TODO: Remove, this is temporary
//        int x1 = 2700;
//        int y1 = 540;
//        createEnemyBat(scale, x1, y1, levelJson.getInt("height"), levelJson.getInt("tileheight"));

        if (levelJson.has("layers")) {
            int levelHeight = levelJson.getInt("height");
            for (JsonValue layer : levelJson.get("layers")) {
                String layerName = layer.getString("name", "");
                switch (layerName) {
                    case "background":
                        // TODO: change background image depending on tiled info – may do this when we
                        // have more levels
                        break;
                    case "walls":
                        int[] data = layer.get("data").asIntArray();
                        int width = layer.getInt("width");
                        int height = layer.getInt("height");
                        for (int i = 0; i < data.length; i++) {
                            int tileTypeID = data[i];
                            // tileTypeID == 0 means there is no tile there
                            if (tileTypeID != 0) {
                                // Get x and y coordinates from where it is in the array
                                int x = i % width;
                                int y = height - (i / width) - 1;
                                createWall(scale, x, y, tileSize);
                            }
                        }
                        break;
                    case "weightedPlatforms":
                        // Sort the synth/jazz weighted platform coordinates into arrays corresponding
                        // to the num value
                        // The index is used to identify a specific platform's synth and jazz position
                        // and its speed
                        float[][] synthCoord = new float[layer.get("objects").size][2];
                        float[][] jazzCoord = new float[layer.get("objects").size][2];
                        float[] wpSpeed = new float[layer.get("objects").size];
                        Vector2[] wpDimensions = new Vector2[layer.get("objects").size];
                        for (JsonValue wp : layer.get("objects")) {
                            int num = 0;
                            String genre = "";
                            float speed = 0;
                            for (JsonValue prop : wp.get("properties")) {
                                switch (prop.getString("name")) {
                                    case "num":
                                        num = prop.getInt("value");
                                        break;
                                    case "genre":
                                        genre = prop.getString("value");
                                        break;
                                    case "speed":
                                        speed = prop.getFloat("value");
                                        break;
                                }
                            }
                            switch (genre) {
                                case "synth":
                                    synthCoord[num] = new float[] { wp.getFloat("x"), wp.getFloat("y") };
                                    break;
                                case "jazz":
                                    jazzCoord[num] = new float[] { wp.getFloat("x"), wp.getFloat("y") };
                                    break;
                            }
                            wpSpeed[num] = speed;
                            wpDimensions[num] = new Vector2(wp.getFloat("width"), wp.getFloat("height"));
                        }
                        //  Now actually create weighted platforms using synthCoord, jazzCoord, wpSpeed
                        for (int i=0; i<layer.get("objects").size/2; i++){
                            createWeightedPlatform(scale, synthCoord[i], jazzCoord[i], wpSpeed[i], wpDimensions[i], levelHeight, tileSize);
                        }
                        break;
                    case "movingPlatforms":
                        HashMap<Integer, Vector2[]> positionNodes = new HashMap<>();
                        HashMap<Integer, Float> mpSpeed = new HashMap<>();
                        HashMap<Integer, Vector2> dimensions = new HashMap<>();
                        for (JsonValue mp : layer.get("objects")) {
                            int num = 0;
                            int pos = 0;
                            float speed = 0;
                            int totalPos = 1; // number of positions in this moving platform
                            for (JsonValue prop : mp.get("properties")) {
                                switch (prop.getString("name")) {
                                    case "num":
                                        num = prop.getInt("value");
                                        break;
                                    case "pos":
                                        pos = prop.getInt("value");
                                        break;
                                    case "speed":
                                        speed = prop.getFloat("value");
                                        break;
                                    case "totalPos":
                                        totalPos = prop.getInt("value");
                                        break;
                                }
                            }
                            // Store coordinates
                            final int numOfNodes = totalPos; // need to be final to be used in computeIfAbsent
                            positionNodes.computeIfAbsent(num, key -> new Vector2[numOfNodes]);
                            Vector2 coord = new Vector2(mp.getFloat("x"), mp.getFloat("y"));
                            Vector2 dim = new Vector2(mp.getFloat("width"), mp.getFloat("height"));
                            positionNodes.get(num)[pos] = coord;

                            // Store speed
                            mpSpeed.put(num, speed);

                            //  Store dimensions
                            dimensions.put(num, dim);
                        }
                        //  Now actually create moving platforms
                        for (int i=0; i<positionNodes.size(); i++){
                            createMovingPlatform(scale, positionNodes.get(i), mpSpeed.get(i), dimensions.get(i), levelHeight, tileSize);
                        }
                        break;
                    case "platforms":
                        for (JsonValue platform : layer.get("objects")) {
                            float x = platform.getFloat("x");
                            float y = platform.getFloat("y");
                            Vector2 dim = new Vector2(platform.getFloat("width"), platform.getFloat("height"));
                            String align = "";
                            boolean lethal = false;
                            System.out.println("thing");
                            if (platform.getString("type").equals( "laser")){
                                lethal = true;
                                System.out.println("lasers");
                            }
                            if (platform.get("properties")!= null){
                                for (JsonValue prop : platform.get("properties")) {
                                    if (prop.getString("name").equals("align")) {
                                        align = prop.getString("value");
                                    }
                                }
                            }

                            createPlatform(scale, align, x, y, dim, levelHeight, tileSize, lethal);
                        }
                        break;
                    case "platformArt":
                        for (JsonValue a : layer.get("objects")) {
                            float x = a.getFloat("x");
                            float y = a.getFloat("y");
                            Vector2 dim = new Vector2(a.getFloat("width"), a.getFloat("height"));
                            createPlatformArt(scale, a.getString("type"), x, y, dim, levelHeight, tileSize);
                        }
                        break;
                    case "player":
                        if (layer.get("objects").size > 0) {
                            JsonValue player = layer.get("objects").get(0);
                            float x = player.getInt("x");
                            float y = player.getInt("y");
                            Vector2 dim = new Vector2(player.getFloat("width"), player.getFloat("height"));
                            createPlayer(scale, x, y, dim, levelHeight, tileSize);
                        }
                        break;
                    case "enemies":
                        // TODO: Read the beatlist actions from Tiled
                        for (JsonValue enemy : layer.get("objects")) {
                            String enemyType = enemy.getString("type");
                            String beatListString = "";
                            for (JsonValue prop : enemy.get("properties")) {
                                if (prop.getString("name").equals("beatList")) {
                                    beatListString = prop.getString("value");
                                }
                            }
                            switch (enemyType) {
                                case "bear":
                                    float x = enemy.getFloat("x");
                                    float y = enemy.getFloat("y");
                                    Vector2 dim = new Vector2(enemy.getFloat("width"), enemy.getFloat("height"));
                                    createEnemyBear(scale, x, y, dim, levelHeight, tileSize, convertTiledbeatList(beatListString));
                                    break;
                                case "beehive":
                                    x = enemy.getFloat("x");
                                    y = enemy.getFloat("y");
                                    dim = new Vector2(enemy.getFloat("width"), enemy.getFloat("height"));
                                    createEnemyBeehive(scale, x, y, dim, levelHeight, tileSize, convertTiledbeatList(beatListString));
                                    break;
                                case "hedgehog":
                                    x = enemy.getFloat("x");
                                    y = enemy.getFloat("y");
                                    dim = new Vector2(enemy.getFloat("width"), enemy.getFloat("height"));
                                    int rollingDistance = 0;
                                    for (JsonValue prop : enemy.get("properties")) {
                                        if (prop.getString("name").equals("rollingDistance")) {
                                            rollingDistance = prop.getInt("value");
                                        }
                                    }
                                    createEnemyHedgehog(scale, x, y, dim, rollingDistance, levelHeight, tileSize, convertTiledbeatList(beatListString));
                                    break;
                                case "bat":
                                    x = enemy.getFloat("x");
                                    y = enemy.getFloat("y");
                                    dim = new Vector2(enemy.getFloat("width"), enemy.getFloat("height"));
                                    createEnemyBat(scale, x, y, dim, levelHeight, tileSize,
                                            convertTiledbeatList(beatListString));
                                    break;
                            }
                        }
                        break;
                    case "checkpoints":
                        for (JsonValue checkpoint : layer.get("objects")) {
                            float x = checkpoint.getFloat("x");
                            float y = checkpoint.getFloat("y");
                            Vector2 dim = new Vector2(checkpoint.getFloat("width"), checkpoint.getFloat("height"));
                            int id = 0;
                            for (JsonValue prop : checkpoint.get("properties")) {
                                if (prop.getString("name").equals("num")) {
                                    id = prop.getInt("value");
                                }
                            }
                            createCheckpoint(scale, x, y, dim, id, levelHeight, tileSize);
                        }
                        break;
                    case "goal":
                        if (layer.get("objects").size > 0) {
                            JsonValue goal = layer.get("objects").get(0);
                            float x = goal.getInt("x");
                            float y = goal.getInt("y");
                            Vector2 dim = new Vector2(goal.getFloat("width"), goal.getFloat("height"));
                            createGoal(scale, x, y, dim, levelHeight, tileSize);
                        }
                        break;
                    case "foregroundArt":
                        for (JsonValue a : layer.get("objects")) {
                            float x = a.getFloat("x");
                            float y = a.getFloat("y");
                            Vector2 dim = new Vector2(a.getFloat("width"), a.getFloat("height"));
                            createGroundArt(scale, a.getString("type"), x, y, dim, levelHeight, tileSize, "foreground");
                        }
                        break;
                    case "backgroundArt":
                        for (JsonValue a : layer.get("objects")) {
                            float x = a.getFloat("x");
                            float y = a.getFloat("y");
                            Vector2 dim = new Vector2(a.getFloat("width"), a.getFloat("height"));
                            createGroundArt(scale, a.getString("type"), x, y, dim, levelHeight, tileSize, "background");
                        }
                        break;
                    case "hangingArt":
                        for (JsonValue a : layer.get("objects")) {
                            float x = a.getFloat("x");
                            float y = a.getFloat("y");
                            Vector2 dim = new Vector2(a.getFloat("width"), a.getFloat("height"));
                            createHangingArt(scale, a.getString("type"), x, y, dim, levelHeight, tileSize);
                        }
                        break;
                }

            }
        }
    }

    /**
     * Convert Tiled coordinates to world coordinates.
     *
     * @param x           The x Tiled coordinate.
     * @param y           The y Tiled coordinate.
     * @param levelHeight The height of the screen (in number of tiles).
     * @param tileSize    The size of the tiles (in pixels).
     * @return A Vector2 object where the x and y attributes are the converted world
     *         coordinates.
     */
    private Vector2 convertTiledCoord(float x, float y, float width, float height, int levelHeight, int tileSize){
        x = x / tileSize;
        y = levelHeight - y / tileSize;
        x = x + (width/(tileSize*2));
        y = y + (height/ (tileSize*2));
        return(new Vector2(x, y));
    }

    /**
     * Converts Tiled beat list String into an int[] value
     * @param beatListString the string representation of the beat list from Tiled
     * @return
     */
    private int[] convertTiledbeatList(String beatListString){
        int listLen = beatListString.length();
        if(listLen == 0){
            return defaultBeatList;
        }
        int[] result = new int[listLen];
        for (int i = 0; i < beatListString.length(); i++) {
            result[i] = Integer.parseInt(beatListString.substring(i, i+1));
        }
        return result;
    }

    /**
     * Create a checkpoint
     */
    private void createCheckpoint(Vector2 scale, float x, float y, Vector2 dimensions, int id, int levelHeight, int tileSize) {
        // Adjust and Convert coordinates to world coordinates
        Vector2 convertedCoord = convertTiledCoord(x, y, dimensions.x, dimensions.y, levelHeight, tileSize);

        if (id == 0) {
            // Set first checkpoint as spawn point
            firstCheckpoint[0] = convertedCoord.x;
            firstCheckpoint[1] = convertedCoord.y;
        }
        float cWidth  = enemyDefaultTexture.getRegionWidth()/scale.x;
        float cHeight = enemyDefaultTexture.getRegionHeight()/scale.y;

        JsonValue defaults = defaultConstants.get("defaults");
        Checkpoint obj = new Checkpoint(id, checkpointInactiveAnimation, checkpointActiveAnimation, checkpointRiseAnimation, convertedCoord.x, convertedCoord.y, cWidth, cHeight);
        obj.setBodyType(BodyDef.BodyType.StaticBody);
        obj.setDensity(defaults.getFloat("density", 0.0f));
        obj.setFriction(defaults.getFloat("friction", 1.0f));
        obj.setRestitution(defaults.getFloat("restitution", 0.0f));
        obj.setSensor(true);
        obj.setDrawScale(scale);
        obj.setTexture(enemyDefaultTexture);
        GameController.getInstance().instantiate(obj);
        checkpoints.add(obj);
    }

    /**
     * Sets the checkpoint with num = 0 as the spawn.
     *
     * @param scale Vector 2 scale used to draw
     */
    public void setFirstCheckpointAsSpawn(Vector2 scale) {
        GameController.getInstance().setSpawn(new Vector2(firstCheckpoint[0], firstCheckpoint[1]));
    }

    /**
     * Create wall tiles
     *
     * @param scale Scale to draw
     * @param x     x coordinate (world coordinates) of tile
     * @param y     y coordinate (world coordinates) of tile
     */
    private void createWall(Vector2 scale, float x, float y, int tileSize){
        String wname = "wall";
        JsonValue defaults = defaultConstants.get("defaults");
        BoxGameObject obj;
        float dwidth  = blackTile.getRegionWidth()/scale.x;
        float dheight = blackTile.getRegionHeight()/scale.y;

        //Adjust coordinate to be center of tile
        float convertedX = x + ((float) blackTile.getRegionWidth()/(tileSize*2));
        float convertedY = y + ((float) blackTile.getRegionHeight()/(tileSize*2));

        obj = new BoxGameObject(convertedX, convertedY, dwidth, dheight);
        obj.setBodyType(BodyDef.BodyType.StaticBody);
        obj.setDensity(defaults.getFloat("density", 0.0f));
        obj.setFriction(defaults.getFloat("friction", 0.0f));
        obj.setRestitution(defaults.getFloat("restitution", 0.0f));
        obj.setDrawScale(scale);
        obj.setTexture(blackTile);
        obj.setName(wname);
        GameController.getInstance().instantiate(obj);
    }

    /**
     * Create a platform.
     *
     * @param scale       The Vector2 draw scale
     * @param align       A string used to determine the alignment (left, mid,
     *                    right)
     * @param x           x coordinate (pixels) for the platform
     * @param y           y coordinate (pixels) for the platform
     * @param levelHeight Height of level in number of tiles
     * @param tileSize    Height of tile in pixels
     */
    private void createPlatform(Vector2 scale, String align, float x, float y, Vector2 dimensions, int levelHeight, int tileSize, boolean lethal){
        TextureRegion textureRegion;
        switch (align) {
            case "left":
                textureRegion = longLeft;
                break;
            case "right":
                textureRegion = longRight;
                break;
            default:
                textureRegion = longMid;
        }
        if (lethal){
            if (align.equals("vertical")){
                System.out.println("vertical");
                textureRegion = laserTileVertical;
            }
            else{
                textureRegion = laserTile;
            }
        }
        //  Convert coordinates to world coordinates
        Vector2 convertedCoord = convertTiledCoord(x, y, dimensions.x, dimensions.y, levelHeight, tileSize);
        convertedCoord.set(convertedCoord.x, convertedCoord.y);

        JsonValue defaults = defaultConstants.get("defaults");
        float dwidth = textureRegion.getRegionWidth() / scale.x;
        float dheight = textureRegion.getRegionHeight() / scale.y;
        BoxGameObject platform;
        platform = new BoxGameObject(convertedCoord.x, convertedCoord.y, dwidth, dheight);
        platform.setBodyType(BodyDef.BodyType.StaticBody);
        platform.setDensity(defaults.getFloat("density", 0.0f));
        platform.setFriction(defaults.getFloat("friction", 0.0f));
        platform.setRestitution(defaults.getFloat("restitution", 0.0f));
        platform.setDrawScale(scale);
        platform.setTexture(textureRegion);
        if (lethal){
            platform.setType(1);

        }
        GameController.getInstance().instantiate(platform);
    }

    /**
     * Create platform art which is not interact-able/collide-able with players.
     *
     * @param scale       The Vector2 draw scale
     * @param type        A string used to determine the texture, either "default",
     *                    or "radio"
     * @param x           x coordinate (pixels) for the platform art
     * @param y           y coordinate (pixels) for the platform art
     * @param levelHeight Height of level in number of tiles
     * @param tileSize    Height of tile in pixels
     */
    private void createPlatformArt(Vector2 scale, String type, float x, float y, Vector2 dimensions, int levelHeight, int tileSize){
        TextureRegion textureRegion;
        switch (type) {
            default:
                textureRegion = platformTileArt;
                break;
            case "radio":
                textureRegion = platformTileArt;
                break;
        }
        //  Convert coordinates to world coordinates
        Vector2 convertedCoord = convertTiledCoord(x, y, dimensions.x, dimensions.y, levelHeight, tileSize);
        convertedCoord.set(convertedCoord.x, convertedCoord.y);

        ArtObject platformArt = new ArtObject(textureRegion, convertedCoord.x, convertedCoord.y);
        platformArt.setBodyType(BodyDef.BodyType.StaticBody);
        platformArt.setDrawScale(scale);
        GameController.getInstance().instantiate(platformArt);
    }

    /**
     * Create a weighted platform.
     *
     * @param scale       The Vector2 draw scale
     * @param synthCoord  A float array which holds the weighted platform's x and y
     *                    coordinates in synth mode
     * @param jazzCoord   A float array which holds the weighted platform's x and y
     *                    coordinates in jazz mode
     * @param speed       The speed of the weighted platform
     * @param levelHeight Height of level in number of tiles
     * @param tileSize    Height of tile in pixels
     */
    private void createWeightedPlatform(Vector2 scale, float[] synthCoord, float[] jazzCoord, float speed, Vector2 dimensions, int levelHeight, int tileSize){
        //  Adjust coordinates + Convert coordinates to world coordinates
//        synthCoord[1] -= weightedSynth.getRegionHeight()/2-4;
        Vector2 convertedSynthCoord = convertTiledCoord(synthCoord[0], synthCoord[1], dimensions.x, dimensions.y, levelHeight, tileSize);
        convertedSynthCoord.set(convertedSynthCoord.x, convertedSynthCoord.y);
//        jazzCoord[1] -= weightedSynth.getRegionHeight()/2-4;
        Vector2 convertedJazzCoord = convertTiledCoord(jazzCoord[0], jazzCoord[1], dimensions.x, dimensions.y, levelHeight, tileSize);
        convertedJazzCoord.set(convertedJazzCoord.x, convertedJazzCoord.y);

        JsonValue defaults = defaultConstants.get("defaults");
        float dwidth = weightedSynth.getRegionWidth() / scale.x;
        float dheight = weightedSynth.getRegionHeight() / scale.y;
        WeightedPlatform weightedPlatform;
        weightedPlatform = new WeightedPlatform(dwidth, dheight,
                new float[] { convertedSynthCoord.x, convertedSynthCoord.y },
                new float[] { convertedJazzCoord.x, convertedJazzCoord.y },
                speed,
                weightedSynth, weightedJazz);
        weightedPlatform.setBodyType(BodyDef.BodyType.StaticBody);
        weightedPlatform.setDensity(defaults.getFloat("density", 0.0f));
        weightedPlatform.setFriction(defaults.getFloat("friction", 1.0f));
        weightedPlatform.setRestitution(defaults.getFloat("restitution", 0.0f));
        weightedPlatform.setDrawScale(scale);
        GameController.getInstance().instantiate(weightedPlatform);
    }

    private void createMovingPlatform(Vector2 scale, Vector2[] positionNodes, float speed, Vector2 dimensions, int levelHeight, int tileSize){
        //  Convert coordinates to world coordinates
        Vector2[] convertedPos = new Vector2[positionNodes.length];
        for(int i=0; i<positionNodes.length; i++){
            convertedPos[i] = convertTiledCoord(positionNodes[i].x, positionNodes[i].y, dimensions.x, dimensions.y, levelHeight, tileSize);
        }

        JsonValue defaults = defaultConstants.get("defaults");
        float dwidth = movingSynth.getRegionWidth() / scale.x;
        float dheight = movingSynth.getRegionHeight() / scale.y;
        MovingPlatform movingPlatform;
        movingPlatform = new MovingPlatform(dwidth, dheight, convertedPos, speed, platformTile);
        movingPlatform.setBodyType(BodyDef.BodyType.StaticBody);
        movingPlatform.setDensity(defaults.getFloat("density", 0.0f));
        movingPlatform.setFriction(defaults.getFloat("friction", 1.0f));
        movingPlatform.setRestitution(defaults.getFloat("restitution", 0.0f));
        movingPlatform.setDrawScale(scale);
        GameController.getInstance().instantiate(movingPlatform);
    }

    /**
     * Create the player object.
     *
     * @param scale       The Vector2 draw scale
     * @param startX      The player's starting x coordinate (pixels)
     * @param startY      The player's starting y coordinate (pixels)
     * @param levelHeight Height of level in number of tiles
     * @param tileSize    Height of tile in pixels
     */
    private void createPlayer(Vector2 scale, float startX, float startY, Vector2 dimensions, int levelHeight, int tileSize){
        //  Convert coordinates to world coordinate
        Vector2 convertedCoord = convertTiledCoord(startX, startY, dimensions.x, dimensions.y, levelHeight, tileSize);

        // TODO: Figure out if having 2 references for player fields is okay
        float dwidth = synthDefaultTexture.getRegionWidth() / scale.x;
        float dheight = synthDefaultTexture.getRegionHeight() / scale.y;
        player = new Player(defaultConstants.get("player"), convertedCoord.x, convertedCoord.y,
                dwidth * playerScale, dheight * playerScale, playerScale);
        player.setDrawScale(scale);

        // Set animations: Synth
        player.synthIdleAnimation = synthIdleAnimation;
        player.synthWalkAnimation = synthWalkAnimation;
        player.synthJumpAnimation = synthJumpAnimation;
        player.synthFallAnimation = synthFallAnimation;
        // Set animations: Jazz
        player.jazzIdleAnimation = jazzIdleAnimation;
        player.jazzWalkAnimation = jazzWalkAnimation;
        player.jazzJumpAnimation = jazzJumpAnimation;
        player.jazzFallAnimation = jazzFallAnimation;

        player.setAnimation(synthWalkAnimation);
        player.synthSpeed = synthSpeed;
        player.jazzSpeed = jazzSpeed;
        player.setTexture(synthDefaultTexture);
        GameController.getInstance().instantiate(player);
    }

    private void createGoal(Vector2 scale, float x, float y, Vector2 dimensions, int levelHeight, int tileSize){
        //  Convert coordinates to world coordinate
        Vector2 convertedCoord = convertTiledCoord(x, y, dimensions.x, dimensions.y, levelHeight, tileSize);

        float dwidth = goalTile.getRegionWidth() / scale.x;
        float dheight = goalTile.getRegionHeight() / scale.y;

        JsonValue data = defaultConstants.get("goal");
        goalDoor = new BoxGameObject(convertedCoord.x, convertedCoord.y, dwidth, dheight);
        goalDoor.setBodyType(BodyDef.BodyType.StaticBody);
        goalDoor.setDensity(data.getFloat("density", 0));
        goalDoor.setFriction(data.getFloat("friction", 0));
        goalDoor.setRestitution(data.getFloat("restitution", 0));
        goalDoor.setSensor(true);
        goalDoor.setDrawScale(scale);
        goalDoor.setTexture(goalTile);
        goalDoor.setName("goal");
        GameController.getInstance().instantiate(goalDoor);
    }

    /**
     * Create a bear enemy.
     *
     * @param scale       The Vector2 draw scale
     * @param x           The bear's x coordinate (in pixels)
     * @param y           The bear's y coordinate (in pixels)
     * @param levelHeight Height of level in number of tiles
     * @param tileSize    Height of tile in pixels
     * @param beatList    The list of beats that the enemy reacts to
     */
    private void createEnemyBear(Vector2 scale, float x, float y, Vector2 dimensions, int levelHeight, int tileSize, int[] beatList){
        //  Convert coordinates to world coordinate
        Vector2 convertedCoord = convertTiledCoord(x, y, dimensions.x, dimensions.y, levelHeight, tileSize);

        float dwidth  = dimensions.x/scale.x;
        float dheight = dimensions.y/scale.y;
        BearEnemy bear = new BearEnemy(defaultConstants.get("bears"), convertedCoord.x, convertedCoord.y,
                dwidth*enemyScale, dheight*enemyScale, enemyScale, false, bearAttackAnimation, beatList);
        bear.setBodyType(BodyDef.BodyType.StaticBody);
        bear.setDrawScale(scale);
        bear.setTexture(bearTexture);
        GameController.getInstance().instantiate(bear);
        System.out.println(dimensions.x + " " + dimensions.y);
        System.out.println(x + " " + y);
        System.out.println(convertedCoord.x + " " + convertedCoord.y);
        System.out.println(bear.getX() + " " + bear.getY());
    }

    /**
     * Create a beehive enemy which releases bees.
     *
     * @param scale       The Vector2 draw scale
     * @param x           The beehive's x coordinate (in pixels)
     * @param y           The beehive's y coordinate (in pixels)
     * @param levelHeight Height of level in number of tiles
     * @param tileSize    Height of tile in pixels
     * @param beatList    The list of beats that the enemy reacts to
     */
    private void createEnemyBeehive(Vector2 scale, float x, float y, Vector2 dimensions, int levelHeight, int tileSize, int[] beatList){
        //  Convert coordinates to world coordinate
        //TODO: change to beehive texture when we get art for this
        Vector2 convertedCoord = convertTiledCoord(x, y, dimensions.x, dimensions.y, levelHeight, tileSize);

        float dwidth  = dimensions.x/scale.x;
        float dheight = dimensions.y/scale.y;
        BeeHive beehive = new BeeHive(defaultConstants.get("beehives"), convertedCoord.x, convertedCoord.y,
                dwidth * enemyScale, dheight * enemyScale, enemyScale,
                false, beehiveAnimation, beatList, beeAttackAnimation);
        beehive.setBodyType(BodyDef.BodyType.StaticBody);
        beehive.setDrawScale(scale);
        beehive.setTexture(beehiveTexture);
        GameController.getInstance().instantiate(beehive);
    }

    /**
     * Create a hedgehog enemy.
     *
     * @param scale           The Vector2 draw scale
     * @param x               The hedgehog's x coordinate (in pixels)
     * @param y               The hedgehog's y coordinate (in pixels)
     * @param rollingDistance The hedgehog's rollingDistance (in world coordinates)
     * @param levelHeight     Height of level in number of tiles
     * @param tileSize        Height of tile in pixels
     * @param beatList    The list of beats that the enemy reacts to
     */
    private void createEnemyHedgehog(Vector2 scale, float x, float y, Vector2 dimensions, int rollingDistance, int levelHeight, int tileSize, int[] beatList){
        //  Convert coordinates to world coordinate
        //TODO: change to hedgehog texture when we get art for this
        Vector2 convertedCoord = convertTiledCoord(x, y, dimensions.x, dimensions.y, levelHeight, tileSize);

        float dwidth  = enemyDefaultTexture.getRegionWidth()/scale.x;
        float dheight = enemyDefaultTexture.getRegionHeight()/scale.y;
        HedgehogEnemy hedgehog = new HedgehogEnemy(defaultConstants.get("hedgehogs"), convertedCoord.x, convertedCoord.y,
                rollingDistance, dwidth*enemyScale, dheight*enemyScale,
                enemyScale, false, beatList, hedgehogAttackAnimation);
        hedgehog.setBodyType(BodyDef.BodyType.StaticBody);
        hedgehog.setDrawScale(scale);
        hedgehog.setTexture(hedgehogTexture);
        GameController.getInstance().instantiate(hedgehog);
        System.out.println(x + " ");
    }

    /**
     * Create a bat enemy.
     *
     * @param scale The Vector2 draw scale
     * @param x  The bear's x coordinate (in pixels)
     * @param y The bear's y coordinate (in pixels)
     * @param levelHeight Height of level in number of tiles
     * @param tileSize Height of tile in pixels
     */
    private void createEnemyBat(Vector2 scale, float x, float y, Vector2 dimensions, int levelHeight, int tileSize, int[] beatList){
        //  Convert coordinates to world coordinate
        Vector2 convertedCoord = convertTiledCoord(x, y, dimensions.x, dimensions.y, levelHeight, tileSize);

        float dwidth  = enemyDefaultTexture.getRegionWidth()/scale.x;
        float dheight = enemyDefaultTexture.getRegionHeight()/scale.y;
        BatEnemy bat = new BatEnemy(defaultConstants.get("bats"), convertedCoord.x, convertedCoord.y,
                dwidth*enemyScale, dheight*enemyScale,
                enemyScale, false, batAttackSynthAnimation, beatList);
        bat.setBodyType(BodyDef.BodyType.StaticBody);
        bat.setDrawScale(scale);
        bat.setTexture(enemyDefaultTexture);
        GameController.getInstance().instantiate(bat);
    }

    private void createGroundArt(Vector2 scale, String type, float x, float y, Vector2 dimensions, int levelHeight, int tileSize, String groundLevel){
        TextureRegion textureRegion = assets.get(type);
        if (textureRegion == null) {
            textureRegion = assets.get("light");
        }
        //  Adjust coordinates + Convert coordinates to world coordinates
        Vector2 convertedCoord = convertTiledCoord(x, y, dimensions.x, dimensions.y, levelHeight, tileSize);
        convertedCoord.set(convertedCoord.x, convertedCoord.y);

        ArtObject art = new ArtObject(textureRegion, convertedCoord.x, convertedCoord.y);
        art.setBodyType(BodyDef.BodyType.StaticBody);
        art.setDrawScale(scale);
        if (groundLevel.equals("foreground")) {
            foreground.add(art);
        }
        GameController.getInstance().instantiate(art);
    }

    private void createHangingArt(Vector2 scale, String type, float x, float y, Vector2 dimensions, int levelHeight, int tileSize){
        TextureRegion textureRegion = assets.get(type);
        if (textureRegion == null) {
            textureRegion = assets.get("light");
        }
        //  Convert coordinates to world coordinates
        Vector2 convertedCoord = convertTiledCoord(x, y, dimensions.x, dimensions.y, levelHeight, tileSize);
        convertedCoord.set(convertedCoord.x, convertedCoord.y);

        ArtObject art = new ArtObject(textureRegion, convertedCoord.x, convertedCoord.y);
        art.setBodyType(BodyDef.BodyType.StaticBody);
        art.setDrawScale(scale);
        GameController.getInstance().instantiate(art);
    }

    /**
     * Creates the in-game UI elements and adds them to the genre/synced objects.
     */
    private void createGUI() {
        genreIndicator = new GenreUI(synthIndicatorTexture, jazzIndicatorTexture, synthCDAnimation, jazzCDAnimation);
        GameController.getInstance().instantiate(genreIndicator);
    }
}
